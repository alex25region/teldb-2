



------------------------------------------------------------------------------
Модель Юзеры (TUsers)

   // Юзер имеет 1 должность:
    public function getPost() {
        //return $this->hasOne("App\Models\TPost");   // можно так
        return $this->hasOne(TPosts::class,'id', 'post_id');
    }

    // Юзер имеет 1 отдел:
    public function getOtdel() {
       return $this->hasOne(TOtdels::class,'id', 'otdel_id');
    }

------------------------------------------------------------------------------
Модель Отделы (TOtdels)

   // Отдел имеет много юзеров:
    public function getUsers() {
        return $this->hasMany(TUsers::class, 'otdel_id', 'id');
    }

------------------------------------------------------------------------------
Модель Должности (TPosts) - НЕ ДЕЛАЛ!

    // Должность имее много юзеров:
    //public function getUsers() {
    //    // return $this->belongsTo(TUsers::class);
    //    return $this->hasMany(TUsers::class, 'post_id', 'id');
    //}

------------------------------------------------------------------------------

Необходимо было вывести сначала отделы и юзеров из этого отдела с отображением должностей:

В контоллере TUsersController метод index:

  public function index()
    {
        $otdels = TOtdels::with('getUsers.getPost')->get()->sortBy('id');

         //тут вложенность getUsers отдает пользователей, принадлежащих к отделу, а
         getPost извлекает должность для пользователя

        //dd( $otdels);
        return view('admin.users.index', compact('otdels'));
    }

В итоге 3 запроса к БД:
select * from `t_otdels`
select * from `t_users` where `t_users`.`otdel_id` in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41)
select * from `t_posts` where `t_posts`.`id` in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

------------------------------------------------------------------------------
В шаблоне blade таблица:

<table class="table table-sm table-bordered table-striped text-center">
        <thead>
        <tr class="thead-light">
            <th>ID</th>
            <th>Фамилия</th>
            <th>Имя</th>
            <th>Отчество</th>
            <th>Должность</th>
            <th>IP-телефон</th>
            <th>Телефон</th>
            <th>Created_at</th>
            <th>Update_at</th>
            <th>Действия</th>
        </tr>
        </thead>
            <tbody>
            @foreach($otdels as $otdel)
                <tr>
                    <th colspan="10">
                        {{ $otdel->id }} <br>
                        {{ $otdel->otdel }} <br>
                        {{ $otdel->address }}
                    </th>
                </tr>
                    @foreach($otdel->getUsers as $user)
                        <tr>
                            <td>{{ $user->id }}</td>
                            <td>{{ $user->surname}}</td>
                            <td>{{ $user->firstname }}</td>
                            <td>{{ $user->secondname }}</td>
                            <td>{{ $user->getPost->post }}</td>
                            <td>{{ $user->iptel }}</td>
                            <td>{{ $user->tel}}</td>
                            <td>{{ $user->created_at}}</td>
                            <td>{{ $user->updated_at}}</td>
                            <td>{{ $user->updated_at}}</td>
                        </tr>
                    @endforeach
            @endforeach
            </tbody>
</table>

=========================================================================
Документация с сайта Laravel:

Активная загрузка (eager loading) призвана устранить проблему запросов N + 1. Например, представьте, что у нас есть модель Book со связью к модели Author.
Отношение определено как:

class Book extends Model {
    public function author()
    {
        return $this->belongsTo('App\Author');
    }

}

Теперь предположим, у нас есть такой код:
    foreach (Book::all() as $book)
        {
            echo $book->author->name;
        }

Цикл выполнит один запрос для получения всех книг в таблице, а затем будет выполнять по одному запросу на каждую книгу для получения автора.
Таким образом, если у нас 25 книг, то потребуется 26 запросов.

К счастью, мы можем использовать активную загрузку для кардинального уменьшения числа запросов.
Отношение будет активно загружено, если оно было указано при вызове метода with():

foreach (Book::with('author')->get() as $book)
    {
        echo $book->author->name;
    }

В цикле выше будут выполнены всего два запроса:

select * from books
select * from authors where id in (1, 2, 3, 4, 5, ...)

Разумное использование активной загрузки поможет сильно повысить производительность вашего приложения.

Конечно, вы можете загрузить несколько отношений одновременно:

$books = Book::with('author', 'publisher')->get();

Вы даже можете загрузить вложенные отношения:

$books = Book::with('author.contacts')->get();

В примере выше связь author будет активно загружена вместе со связью contacts модели автора.

Загружать определенные столбцы
Вам не всегда может понадобиться каждый столбец из отношений, которые вы извлекаете. По этой причине Eloquent позволяет указать,
какие столбцы отношений вы хотите получить:

$books = App\Book::with('author:id,name')->get();
При использовании этой функции вы всегда должны включать id,столбец и все соответствующие столбцы внешнего ключа в список столбцов,
которые вы хотите получить.

http://unetway.com/tutorial/laravel-relationships/